[
  {
    "question": "Co oznacza model grafowy w bazie Neo4j?",
    "options": [
      "Reprezentację danych w tabelach",
      "Reprezentację danych w postaci węzłów i relacji",
      "Hierarchiczną strukturę danych",
      "Struktury drzewa binarnego"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jak nazywa się podstawowy język zapytań w Neo4j?",
    "options": [
      "SQL",
      "GraphQL",
      "Cypher",
      "SPARQL"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Które z poniższych stwierdzeń najlepiej opisuje sieci złożone?",
    "options": [
      "Mają wyłącznie strukturę hierarchiczną",
      "Składają się z wielu elementów o losowych połączeniach",
      "Charakteryzują się nierównomiernym rozkładem stopni węzłów",
      "Są zawsze planarne"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Który typ sieci ma własności „świata małego”?",
    "options": [
      "Sieci losowe",
      "Sieci skali swobodnej",
      "Sieci małego świata",
      "Sieci hierarchiczne"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "W języku Cypher , jak dodajemy nowy węzeł do grafu?",
    "options": [
      "INSERT INTO Node",
      "CREATE (n)",
      "ADD NODE",
      "CREATE NODE"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jaka jest różnica między węzłem a relacją w Neo4j?",
    "options": [
      "Węzeł opisuje połączenie między danymi, a relacja opisuje sam obiekt",
      "Relacja łączy węzły, a węzeł to jednostka danych",
      "Węzeł zawiera metadane, a relacja dane",
      "Węzeł jest dynamiczny, a relacja statyczna"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Który z poniższych przykładów Cypher znajduje wszystkie węzły typu \"Person\"?",
    "options": [
      "MATCH ( p:Person ) RETURN p",
      "SELECT * FROM Person",
      "FIND Person",
      "GET (Person)"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Czym charakteryzują się sieci skali swobodnej?",
    "options": [
      "Równomiernym rozkładem stopni węzłów",
      "Obecnością węzłów o bardzo dużym stopniu ( hubs )",
      "Stałą liczbą połączeń między węzłami",
      "Brakiem kluczowych węzłów"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jak w Neo4j reprezentowana jest właściwość węzła?",
    "options": [
      "Jako para klucz -wartość",
      "Jako oddzielny węzeł",
      "Jako dynamiczna relacja",
      "Jako metadane"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Jak w Cypher definiujemy relację skierowaną?",
    "options": [
      "(a) -[r]->(b)",
      "(a)< -[r]-(b)",
      "(a)< ->[r](b)",
      "[a ->b]"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Jakie zapytanie w Cypher usuwa węzeł i jego relacje?",
    "options": [
      "DELETE NODE n",
      "MATCH (n) DELETE n",
      "MATCH (n) DETACH DELETE n",
      "REMOVE n"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "W interfejsach programistycznych baz danych niemożliwe jest mapowanie klas zawierających pola o typach użytkownika(zdefiniowanie klasy lub typy wyliczeniowe), możliwe jest wyłącznie mapowanie klas zawierając pola o typach prostych(liczbowe, tekstowe, numeryczne, logiczne)",
    "options": [
      "Prawda",
      "Fałsz"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jakie cechy ma sieć losowa Erdos -Renyi ?",
    "options": [
      "Każdy węzeł ma dokładnie jedną relację",
      "Połączenia między węzłami są tworzone z równym prawdopodobieństwem",
      "Stopnie węzłów są skoncentrowane wokół jednego węzła",
      "Sieci te są zawsze drzewami"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jak w Cypher filtrować węzły na podstawie właściwości?",
    "options": [
      "MATCH (n) WHERE n.property =value RETURN n",
      "FILTER ( n.property =value)",
      "SELECT n FROM WHERE n.property =value",
      "MATCH ( n.property =value)"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Który z poniższych operatorów w Cypher reprezentuje związek między węzłami?",
    "options": [
      ":",
      "->",
      "--",
      "||"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "W jakim przypadku używamy zapytania MERGE w Cypher ?",
    "options": [
      "Gdy chcemy usunąć węzeł",
      "Gdy chcemy upewnić się, że element istnieje",
      "Gdy chcemy znaleźć wszystkie węzły",
      "Gdy chcemy zaktualizować relacje"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Co oznacza termin „centralność węzła” w sieciach złożonych?",
    "options": [
      "Odległość węzła od centrum grafu",
      "Znaczenie węzła w kontekście całej sieci",
      "Liczbę węzłów sąsiednich",
      "Liczbę właściwości węzła"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Które zapytanie Cypher znajduje najkrótszą ścieżkę między dwoma węzłami?",
    "options": [
      "MATCH SHORTEST (a) -[r]->(b)",
      "MATCH (a) -[r*]->(b) RETURN length(r)",
      "MATCH p= shortestPath ((a)-[*]->(b)) RETURN p",
      "FIND SHORTEST PATH"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Dopasuj do definicji: Podniesienie wydajności poprzez dodanie większej liczby maszyn ",
    "options": [
      "skalowanie wertykalne (pionowe)",
      "horyzontalne (poziome)",
      "skalowanie systemowe"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Dopasuj definicję do typu replikacji: Klienci wysyłają każdy zapis do kilku węzłów i odczytują z kilku węzłów równolegle w celu wykrycia i skorygowania węzłów z nieaktualnymi danymi.",
    "options": [
      "Single-leader replication",
      "Multi-leader replication",
      "Leadless replication"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Czym jest graf RDF w kontekście baz danych?",
    "options": [
      "Typem sieci złożonej",
      "Modelem danych dla semantycznych sieci grafowych",
      "Językiem zapytań dla Neo4j",
      "Bazą danych dokumentów"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Co oznacza symbol „ : ” w Cypher ?",
    "options": [
      "Typ węzła lub relacji",
      "Separację warunków",
      "Operator przypisania",
      "Przypisanie właściwości"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Jak oznaczamy relacje w języku Cypher ?",
    "options": [
      "{rel}",
      "[rel]",
      "(rel)",
      "<rel>"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jak w Neo4j oznacza się relacje o określonym typie w Cypher ?",
    "options": [
      "MATCH (a) -[:REL] ->(b)",
      "MATCH (a) -[REL] -(b)",
      "MATCH (a) -[:RELATION] ->(b)",
      "MATCH (a) -[REL:TYPE] -(b)"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Jak w Cypher odczytać właściwość relacji?",
    "options": [
      "r[property]",
      "r.property",
      "property(r)",
      "[r].property"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Która z poniższych jest poprawną składnią dla Cypher ?",
    "options": [
      "MATCH (n) -[r]->(m)",
      "SELECT n, r, m",
      "FIND n, r, m",
      "GET (n)<[r](m)"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Co oznacza podejście ACID w Neo4j?",
    "options": [
      "Atomiczność , spójność, izolacja, trwałość",
      "Analiza, korelacja, implementacja, dystrybucja",
      "Agregacja, ciągłość, interakcja, dywersyfikacja",
      "Automatyzacja, cykliczność, izolacja, dostosowanie"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Który algorytm można zastosować do wykrywania społeczności w grafie?",
    "options": [
      "Algorytm Dijkstry",
      "Algorytm Louvaina",
      "Algorytm Bellmana -Forda",
      "Algorytm A*"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Które zapytanie Cypher znajdzie wszystkie węzły połączone bezpośrednio z węzłem a?",
    "options": [
      "MATCH (a) -[]-(b) RETURN b",
      "MATCH (a) ->(b) RETURN b",
      "MATCH (a)< -(b) RETURN b",
      "MATCH (a) RETURN (b)"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Jaka jest różnica między MATCH a OPTIONAL MATCH w Cypher ?",
    "options": [
      "MATCH ignoruje błędy, OPTIONAL MATCH je uwzględnia",
      "OPTIONAL MATCH zwraca wyniki nawet, gdy brak dopasowań",
      "MATCH zwraca brak wyników przy braku dopasowań",
      "Brak różnicy"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jakie jest zastosowanie języka Cypher ?",
    "options": [
      "Zarządzanie dokumentami",
      "Zapytania grafowe",
      "Analiza danych tabelarycznych",
      "Optymalizacja maszyn wirtualnych"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Który operator w Cypher reprezentuje powtarzające się relacje?",
    "options": [
      "[r*]",
      "[r+]",
      "[r?]",
      "[r{n}]"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Co oznacza pojęcie „gęstość grafu”?",
    "options": [
      "Proporcję liczby węzłów do relacji",
      "Stosunek istniejących połączeń do maksymalnej możliwej liczby połączeń",
      "Liczbę kluczowych węzłów",
      "Liczbę izolowanych komponentów"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Jak w Neo4j definiujemy etykiety dla węzłów?",
    "options": [
      "n:Label",
      "LABEL n:Type",
      "DEFINE Label n",
      "n[Label]"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Które zapytanie w Cypher tworzy relację między węzłami?",
    "options": [
      "MATCH (a), (b) CREATE (a) -[r]->(b)",
      "ADD (a) -[r]->(b)",
      "DEFINE RELATION (a) ->(b)",
      "CONNECT (a) ->(b)"
    ],
    "correct": [
      0
    ]
  },

  {
    "question": "Asocjacja jednokierunkowa w mapowaniu obiektowo-relacyjnym oznacza:",
    "options": [
      "Relację pomiędzy obiektami w kolekqi obiektów wczytanych z bazy danych narzucającą kolejność oraz kierunek ich przeglądania",
      "Możliwość wyłącznie wczytywania obiektów określonego typu bez możliwości ich zapisu",
      "Relację pomiędzy obiektami, w któreł wyłącznie strona właściciela relacji posiada referencję do obiektu (lub obiektów) strony przeciwnej"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Ekspresyjny język zapytań w grafowych bazach danych, odpowiednik SQLa z baz relacyjnych to",
    "options": [
      "Cyber",
      "GraphSQL",
      "GraphDB",
      "Cypher"
    ],
    "correct": [
      3
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które są prawdziwe w kontekście teorii CAP dotyczącej:",
    "options": [
      "Udowodniono, że ta teoria jest już nieaktualna.",
      "Bazy danych mogą spełniać tylko jedno z tych kryteriów.",
      "Teoria CAP dotyczą baz relacyjnych i nierelacyjnych.",
      "Wybrane bazy danych mogą spełniać jednocześnie wszystkie trzy kryteria.",
      "Bazy danych mogą spełniać jednoczesnie tylko dwa z tych kryteriów."
    ],
    "correct": [
      2,
      4
    ]
  },
  {
    "question": "Miara pośrednictwa w strukturych sieciowych określa",
    "options": [
      "Znaczenie węzła w przesyle informacji pomiędzy segmentami sieci",
      "Liczbę sąsiadów pośredniczących w przesyle informacji",
      "Liczbę kontaktów w transmisji informacji"
    ],
    "correct": [
      0
    ]
  },
    {
    "question": "Zakładając, że klaster składa się z 11 węzłów umieszczonych w dwóch centrach danych (w Centrum 1 jest 6 węzłów, a w Centrum 2 jest 5 węzłów). W Cassandrze ustawiony jest CONSISTENCY QUORUM, a replication factor jest ustawiony na 6. Podaj ile węzłów będzie musiało potwierdzić zapis nowych danych do klastra, aby operacja się zakończyła sukcesem.",
    "options": [
      "3",
      "4",
      "5"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Wybierz stwierdzenia dotyczące baz typu klucz-wartość (key-value):",
    "options": [
      "Można w nich przechowywać tylko proste struktury danych.",
      "Bardzo łatwo jest je skalować.",
      "Są bardzo szybkie.",
      "Można w nich przechowywać złozone struktury danych.",
      "Przykładami baz klucz-wartość są MongoDB i CouchDB."
    ],
    "correct": [
      1,
      2,
      4
    ]
  },
  {
    "question": "Wybierz bazy, które należą do kategorii NoSQL",
    "options": [
      "MongoDB",
      "MariaDB",
      "Neo4J",
      "Dynamo",
      "PostgreSQL",
      "Cassandra",
      "Oracle",
      "BigTable"
    ],
    "correct": [
      0,
      2,
      3,
      5,
      7
    ]
  },
  {
    "question": "Wynikiem zapytań w grafoweJ bazie danych Ne04J moze być",
    "options": [
      "Tabela z numerycznymi i tekstowymi danymi wynikowymi",
      "Wizualizacja grafu",
      "Ścieżka łącząca zadane węzły"
    ],
    "correct": [
      0,
      1,
      2
    ]
  },
  {
    "question": "Query Builder w interfejsach programistycznych baz danych:",
    "options": [
      "Wprowadza altematywny dla SQL język zapytań do bazy danych",
      "Zmniejsza ryzyko sformułowania niepoprawnego zapytania",
      "Umozliwia automatyczne generowanie struktury tabel w bazie danych na podstawie pól klas zdefiniowanych w aplikacji",
      "Pozwala na budowanie zapytań w oparciu łańcuchowo wywoływane metody formułujące poszczególne ich części."
    ],
    "correct": [
      1,
      3
    ]
  },
  {
    "question": "Rozprzestrzenianie informacji w mediach społecznościowych może być modelowane z wykorzystaniem",
    "options": [
      "modelu SIR",
      "modeli epidemiologicznych",
      "systemów agentowych"
    ],
    "correct": [
      0,
      1,
      2
    ]
  },
  {
    "question": "Wybierz systemy baz danych pracujących w architekturze Leaderless replication",
    "options": [
      "MySQL",
      "MongoDB",
      "PostreSQL",
      "Amazon Dynamo",
      "Cassandra"
    ],
    "correct": [
      3,
      4
    ]
  },
  {
    "question": "Możliwe stany węzłow słecł w modelu rozprzestrzenianła informacji SIR to",
    "options": [
      "Susceptible Infected Recovered",
      "Susceptible Interested Recovered",
      "Selected Infected Recovered"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Grafowa baza danych",
    "options": [
      "zapewnia dedykowane funkcje przetwarzania grafów",
      "zapewnia możliwość wyznaczania najkrótszych ścieżek",
      "wprowadza nowe funkcje do Języka SQL"
    ],
    "correct": [
      0,
      1
    ]
  },
  {
    "question": "Przechowują dane tak. aby oni sami lub inna aplikacja mogła je później odnaleźć",
    "options": [
      "bazy danych",
      "indeksy",
      "przetwarzanie strumieniowe (stream)",
      "cache",
      "przetwarzanie wsadowe (batch)"
    ],
    "correct": [
      0
    ]
  },
    {
    "question": "Pozwalają użytkownikom na wyszukiwanie danych według słów kluczowych lub filtrowanie ich na różne sposoby",
    "options": [
      "bazy danych",
      "indeksy",
      "przetwarzanie strumieniowe (stream)",
      "cache",
      "przetwarzanie wsadowe (batch)"
    ],
    "correct": [
      1
    ]
  },
    {
    "question": "Wysyłają wiadomość do innego procesu aby została obsłużona asynchronicznie",
    "options": [
      "bazy danych",
      "indeksy",
      "przetwarzanie strumieniowe (stream)",
      "cache",
      "przetwarzanie wsadowe (batch)"
    ],
    "correct": [
      2
    ]
  },
    {
    "question": "Zapamiętują wynik operacji. aby przyspieszyć odczyt",
    "options": [
      "bazy danych",
      "indeksy",
      "przetwarzanie strumieniowe (stream)",
      "cache",
      "przetwarzanie wsadowe (batch)"
    ],
    "correct": [
      3
    ]
  },
    {
    "question": "Okresowo pobierają i przetwarzają duzą ilość zgromadzonych danych.",
    "options": [
      "bazy danych",
      "indeksy",
      "przetwarzanie strumieniowe (stream)",
      "cache",
      "przetwarzanie wsadowe (batch)"
    ],
    "correct": [
      4
    ]
  },
  {
    "question": "Które z wymienionych interfejsów programistycznych działają w warstwie abstrakcji bazy danych (w zakresie reprezentowania danych)",
    "options": [
      "Doctrine ORM",
      "PHP Data Objects (PDO)",
      "Java Database Conectivity (JDBC)",
      "Java/Jakarta Persistence API (JPA)",
      "Doctrine DBAL"
    ],
    "correct": [
      1,
      2,
      4
    ]
  },
  {
    "question": "W Języku Cypher odpowiednikiem polecenia SELECT Jest:",
    "options": [
      "PATH",
      "MATCH",
      "SEARCH"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "NetLogo to",
    "options": [
      "System modelowania i symulacji wieloagentowych",
      "Język programowania oparty na języku Logo",
      "System grafowych baz danych"
    ],
    "correct": [
      0,
      1
    ]
  },
  {
    "question": "Wybierz stwierdzenia. które odnoszą się do protokołu snitch",
    "options": [
      "Informują Cassandrę o topologii sieci, aby żądania były kierowane efektywnie i pozwalają Cassandrze na dystrybucję replik poprzez grupowanie maszyn w centra danych i szafy.",
      "Cassandra decyduje, czy węzeł jest włączony, czy wyłączony na podstawie tego, czy moze się z nim połączyć z poprzez snitch'a, co pomaga w optymalnym kierowaniu żądań w ramach klastra",
      "Informacje są wykorzystywane do określenia, z których węzłów czytać i do których pisać, a także jak najlepiej"
    ],
    "correct": [
      0,
      2
    ]
  },
  {
    "question": "Wymień etapy procesu modelowania danych na potrzeby Cassandry",
    "options": [
      "Relacyjny model danych",
      "Znormalizowany model danych",
      "Model konceptualny wraz z modelem przypływu danych w aplikacji ",
      "Logiczny model danych",
      "Fizyczny model danych"
    ],
    "correct": [
      2,
      3,
      4
    ]
  },
  {
    "question": "Podstawą do wyznaczenia miary closeness w analizach sieci są",
    "options": [
      "najdłuższe ściezki",
      "najkrótsze ścieżki",
      "połączenia dwukierunkowe"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Stopień wierzchołka",
    "options": [
      "jest jedną z miar centralności sieci",
      "określa liczbę sąsiadów węzła",
      "jest podstawą do wyznaczania długości ściezek"
    ],
    "correct": [
      0,
      1
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które opisują model danych w Cassandrze",
    "options": [
      "Dane Są przechowywane w wierszach",
      "Dane tabeli są rozrzucone po różnych węzłach",
      "Dane całej tabeli są przechowywane w jednym węźle.",
      "Wszystkie wiersze tabeli muszą zawierać taki sam zestaw kolumn.",
      "Wiesze w tabeli mogą składać się z różnych wierszy.",
      "Dane są przechowywane w kolumnach"
    ],
    "correct": [
      1,
      5
    ]
  },
  {
    "question": "Wybierz stwierdzenia. które odnoszą się o protokołu gossip",
    "options": [
      "Co sekundę i wymienia wiadomości o stanie ze wszystkimi innymi węzłami w klastrze.",
      "Wiadomość ma przypisaną wersję. dzięki czemu podczas wymiany starsze informacje są nadpisywane najbardziej aktualnym stanem dla danego węzła.",
      "Jest protokołem komunikacyjnym typu peer-to-peer, w którym węzły okresowo wymieniają informacje o swoim starue oraz o innych znanych im węzłach.",
      "Informuje Cassandrę 0 topologii Sieci, tak aby żądania były kierowane efektywnie."
    ],
    "correct": [
      1,
      2,
      3
    ]
  },
  {
    "question": "Technika mapowania obiektowo-relacyjnego:",
    "options": [
      "Podnosi wydajność operacji zapisu i odczytu do bazy danych",
      "Wymaga stosowania w obiektowym modelu danych wyłącznie typów danych dostępnych w wykorzystywanym systemie bazodanowym",
      "Automatyzuje proces zakładania, definiowania i aktualizowania struktur tabel w bazie danych",
      "Umożliwia reprezentowanie struktur obiektowych w relacyjnej bane danych"
    ],
    "correct": [
      2,
      3
    ]
  },
  {
    "question": "Wybierz systemy baz danych, które w środowisku rozproszonym pracują w architekturze Single-leader replication:",
    "options": [
      "Oracle",
      "MongoDB",
      "PosgreSQL",
      "Cassandra",
      "MySQL"
    ],
    "correct": [
      0,
      1,
      2,
      4
    ]
  },
  {
    "question": "Uporządkuj struktury danych w bazie Cassandra od poziomu najwyższego (największego kontenera) do najniższego (najmniejszej jednostki):",
    "options": [
      "Klaster, Tabela, Przestrzeń kluczy, Partycja, Wiersz, Kolumna",
      "Przestrzeń kluczy, Klaster, Tabela, Wiersz, Partycja, Kolumna",
      "Klaster, Przestrzeń kluczy, Tabela, Partycja, Wiersz, Kolumna",
      "Klaster, Przestrzeń kluczy, Partycja, Tabela, Wiersz, Kolumna"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które odnoszą się do Cassandra Query Language",
    "options": [
      "Wszystkie kolumny klucza głównego muszą być określone w klauzuli WHERE w celu zidentyfikowania konkretnego wiersza, którego to dotyczy.",
      "Można łączyć dane operatorem JOIN tylko z dwóch tabel.",
      "Możliwe jest jedynie grupowanie wierszy na poziomie klucza partycji lub na poziomie kolumny grupującej.",
      "Zapytanie musi odwoływać się tylko do danych umieszczonych w jednej partycji.",
      "Nie obsługuje funkcji agregujących."
    ],
    "correct": [
      0,
      2
    ]
  },
  {
    "question": "Pule połączeń (ang. connection pool) stosowane w interfejsach programistycznych baz danych",
    "options": [
      "Ograniczają blokowanie dostępu do połączenia z bazą danych w aplikacjach wielowątkowych",
      "Zapewnłają aplikacji dostęp do zestawu wielu jednocześnie otwartych połączeń do tej samej bazy danych",
      "Redukują konieczny narzut czasowy potrzebny na nawiązywanie nowego połączenła przez aplikację",
      "Zapewnłają aplikacji dostęp do zestawu wielu jednocześnie otwartych połączeń do różnych baz danych"
    ],
    "correct": [
      0,
      1,
      2
    ]
  },
  {
    "question": "Sterowniki w interfejsach programistycznych dla relacyjnych baz danych (takich jak np. PDO lub JDBC)",
    "options": [
      "umozliwiaJą rozszerzenie tych interfeJsOw o nowsze wersje języka zapytań SQL",
      "zapewniają możliwość jednolitego komunikowania się z bazami danych od różnych dostawców",
      "umozliwiają rozszerzenie możliwości obsługiwanych baz danych o nowe typy danych dla kolumn oraz dodatkowe mechanizmy indeksowania"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Wybierz typ(y) partycjonowania wykorzystywane przez Cassandrę:",
    "options": [
      "Funkcja mieszająca (hash partitioning)",
      "W Cassandrze nie jest zaimplementowane partycjonowanie.",
      "Sortowanie leksykograficzne (key range partitioning)"
    ],
    "correct": [
      0,
      2
    ]
  },
  {
    "question": "Mechanizm szablonów zapytań SQL stosowany w interfejsach programistycznych baz danych",
    "options": [
      "Umożliwia przesłanie wartości parametrów do szablonu zapytania SQL zapisanego wcześniej w systemie bazy danych",
      "Umozliwia wstawienie wartości parametrów do zapytania SQL i następnłe przesłanie kompletnego zapytania do systemu bazy danych w celu wykonania"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Język SQL trudno stosować do analizy struktur sieciowych ponieważ:",
    "options": [
      "działa zbyt wolno",
      "są one zbyt duże",
      "nie posiada dedykowanych analiz sieciowych"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które są prawdziwe",
    "options": [
      "Nie można wykorzystywać baz relacyjnych w środowisku rozproszonym.",
      "Bazy NoSQL lepiej się nadają do przechowywania duzych zbiorów danych w środowisku rozproszonym",
      "Bazy relacyone są bardziej uniwersalne od baz NoSQL",
      "Model ACID Jest wykorzystywany w bazach NoSQL",
      "Bazy NoSQL są bazami bardziej uniwersalnymi niž bazy relacyjne."
    ],
    "correct": [
      1,
      2
    ]
  },
  {
    "question": "Dopasuj definicję do typu replikacji:  Klienci wysyłają wszystkie zapisy do Jednego węzła, który wysyła strumień zdarzeń zmiany danych do innych replik",
    "options": [
      "Single-leader replication",
      "Multi-leader replication",
      "Leadless replication"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Menadżer encji w interfejsach programistycznych baz danych to",
    "options": [
      "rola członka zespołu w projekcie informatycznym odpowiedzialna za projekt i implementację struktur bazy danych",
      "wzorzec projektowy klasy umożliwiający tworzenie nowych obiektów reprezentujący dane przetwarzane w aplikacji",
      "wzorzec projektowy klasy odpowiadającej za zapis i odczyt w bazie danych obiektów reprezentujących dane w aplikacji"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Kaskadowość w technikach mapowania obiektowo-relacyjnego polega na: ",
    "options": [
      "Wczytywaniu kolekcji obiektów jednego typu w kolejności zgodnej z wartościami identyfikatora,",
      "Możliwość łączenia operacji na bazie danych w grupy i wykonywania ich w ustalonej kolejności",
      "Wczytywaniu, zapisywaniu lub usuwaniu obiektu właściciela relacji wraz z obiektami podległymi"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Wybierz struktury danych, które zapisane są w każdej komórce Cassandry (na przecięciu wiersza i kolumny)",
    "options": [
      "Wartość zgodnie z zadeklarowanym typem danych",
      "Typ danych",
      "Czas życia (time to live)",
      "Znacznik czasu (timestamp)"
    ],
    "correct": [
      0,
      3
    ]
  },
  {
    "question": "W kontekście ETL:",
    "options": [
      "Load oznacza załadowanie danych do hurtowni danych",
      "Extract oznacza pozyskiwanie danych ze źródłowych systemów operacyjnych lub archiwalnych",
      "ETL wykonuje się zazwyczaj raz dziennie w godzinach wysokiego obciążenia systemów źródłowych",
      "Transform oznacza przekształcanie danych - co może obejmować czyszczenie, filtrowanie, walidację, wzbogacanie i stosowanie reguł biznesowych"
    ],
    "correct": [
      0,
      1,
      3
    ]
  },
  {
    "question": "Wybierz stwierdzenia poprawne w kontekście hurtowni danych:",
    "options": [
      "Przeznaczone są do celów analitycznych, odkrywania wiedzy z danych",
      "Wykorzystują relacyjny model danych",
      "Dane mogą pochodzić z wielu źródeł",
      "Przetwarzają dane z wykorzystaniem transakcji",
      "Dane ładowane są w trybiewsadowym z wykorzystaniem ETL"
    ],
    "correct": [
      0,
      2,
      4
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które są prawdziwe w kontekście baz NOSQL:",
    "options": [
      "Spełniają wymagania własności ACID",
      "Są bazami bardziej uniwersalnymi niż bazy relacyjne",
      "Lepiej się nadają do przechowywania dużych zbiorów danych w środowisku rozproszonym",
      "Głównym językiem zapytań jest SQL lub jego odmiana",
      "Głównie skaluje się je w poziomie"
    ],
    "correct": [
      2,
      4
    ]
  },
  {
    "question": "Pojedynczy dokument przechowywany w kolekcji w bazie MongoDB:",
    "options": [
      "Musi posiadać zdefiniowany dla danej kolekcji zestaw pól o określonych nazwach i typach danych",
      "Musi posiadać zdefiniowany dla danej kolekcji zestaw pól o określonych nazwach",
      "Może posiadać dowolny zestaw pól"
    ],
    "correct": [
      2
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które opisują model danych w Cassandrze",
    "options": [
      "Wszystkie wiersze tabeli muszą zawierać taki sam zestaw kolumn.",
      "Wiesze w tabeli mogą składać się z różnych wierszy.",
      "Na jednym klastrze może być tylko jeden „key space-",
      "Dane całej tabeli Są przechowywane w jednym węźle.",
      "Dane tabeli są rozrzucone po węzłach."
    ],
    "correct": [
      4
    ]
  },
  {
    "question": "Czy w interfejsach programistycznych baz danych wykorzystujących techniki ORM możliwe jest mapowanie klas powstałych w wyniku dziedziczenia?",
    "options": [
      "Prawda",
      "Fałsz"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Dopasuj do definicji: Podniesienie wydajności pojedynczej maszyny ",
    "options": [
      "skalowanie wertykalne (pionowe)",
      "horyzontalne (poziome)",
      "skalowanie systemowe"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Dopasuj definicję do typu replikacji: Klienci wysyłaJą każdy zapis do jednego z kilku węzłów liderów, z których każdy može przyjmować zapisy.",
    "options": [
      "Single-leader replication",
      "Multi-leader replication",
      "Leadless replication"
    ],
    "correct": [
      1
    ]
  },

  {
    "question": "Dopasuj definicję typu indeksowania w środowisku rozproszonym: Indeksy wtórne przechowywane są w tej samej partycji co klucz główny i wartość. Oznacza to, że tylko jedna partycja musi być aktualizowana przy zapisie, a odczyt indeksu wtórnego wymaga rozproszenia/zgromadzenia we wszystkich partycjach.",
    "options": [
      "indeksy globalne",
      "indeksy lokalne",
      "indeksy partycjonujące"
    ],
    "correct": [
      1
    ]
  },
  {
    "question": "Dopasuj definicję typu indeksowania w środowisku rozproszonym: Indeksy wtórne są partycjonowane oddzielnie, przy użyciu wartości indeksowanych. Wpis w indeksie wtórnym może zawierać rekordy ze wszystkich partycji klucza głównego. Gdy dokument jest zapisywany, kilka partycji indeksu wtór musi zostać zaktualizowanych; odczyt może być obsługiwany z pojedynczej partycji.",
    "options": [
      "indeksy globalne",
      "indeksy lokalne",
      "indeksy partycjonujące"
    ],
    "correct": [
      0
    ]
  },
  {
    "question": "Wybierz stwierdzenia, które odnoszą Się do Cassandry.",
    "options": [
      "Jest to rozproszona baza danych bez lidera.",
      "Każdy węzeł może być węzłem koordynującym.",
      "Jest to rozproszona baza danych z wieloma liderami.",
      "Jest to rozproszona baza danych z Jednym liderem.",
      "Tylko wybrane węźle (seeds) modą być węzłami koordynującymi."
    ],
    "correct": [
      0,
      1
    ]
  }
]
